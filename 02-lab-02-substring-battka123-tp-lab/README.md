# Лабораторная работа №2

## Отчёт

1. Наивный поиск подстроки в строке

Подходит для маленьких подстрок и очень прост.
Сравнивает символ подстроки и строки, неподходит — идёт дальше.

Cложность: O(mn)

![str](https://user-images.githubusercontent.com/55855887/236196949-9d2c27a0-1404-4013-aec0-7d4d0df1457b.png)

2. Поиск Рабина-Карпа

Используется полиномиальный хеш. Считаем хэш подстроки длины n, потом
сравниваем с хэшом строки [0;n-1], сдвигаем правее и также сравниваем.
Если хэш совпадает, сравниваем символы подстроки и данной части строки.
Недостаток: может быть большой хэш.
Плюсс в том, что алгорим имеет хорошее быстродействе.

Сложность: О(n) в среднем, O(mn) в худшем случае.

![rk_str](https://user-images.githubusercontent.com/55855887/236197000-037b31df-3461-4a06-a289-2c2a980f1e75.png)

3. Алгоритм Кнута—Морриса—Пратта

   Имеет сложность времени O(n), а сложность по памяти O(m).
   Похож на наивный алгоритм, но при несовпадении использует функцию LPS
   
![kmp_str](https://user-images.githubusercontent.com/55855887/236197059-13436e88-11ef-4c5e-9b1b-489dac87a0ee.png)

![lps_func](https://user-images.githubusercontent.com/55855887/236197068-605a00d3-d244-4dbf-93fd-4dc361e82dba.png)

4. Вывод

Существует много алгоритмов для поиска подстроки в строке, которые отличаются сложностью выполнения программы. 
Например, для маленького текста достаточно и наивного поиска. Но есть и огромные документы, поэтому нужно ускорить поиск. 
Также алгоритмы зависят от оптимизации и выбора размера алфавита. 
Заметил, что, если меньше циклов (меньше проходимся по тексту), то алгоритм работает быстрее.
Поэтому, если бы у меня был выбор из рассмотренных алгоритмов, то я бы выбрал алгоритм Кнута—Морриса—Пратта, так как у него есть такая особенность, как линейный поиск.


## Цель
Целью работы является повышение навыков разработки широкоизвестных алгоритмов.

Предпологается, во время выполнения данной работы студенту придется много взаимодействовать с отладчиком, что повысит уровень владения этим инструментом.

Для эффективной реализации алгоритмов придется использовать [профайлер](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%84%D0%B8%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)).

После выполнения работы студент должен понимать разные алгоритмы поиска подстроки, уметь их реализовывать, уверенно владеть отладчиком, получить базовые навыки работы с отладчиком и понимать принцип сравнения производительности кода.

## Задание

1. Реализуйте поиск подстроки в строке.
```cpp
size_t str_find(const std::string& str, const std::string& substr);
```

2. Реализуйте поиск подстроки в строке алгоритмом Рабина—Карпа.
```cpp
size_t rk_find(const std::string& str, const std::string& substr);
```

3. Реализуйте поиск подстроки в строке алгоритмом Кнута—Морриса—Пратта.
```cpp
size_t kmp_find(const std::string& str, const std::string& substr);
```

4. Сравните производительность всех реализованных алгоритмов поиска и метода `std::string::find`. Составьте отчет. Отчет должен включать в себя:
    * описание алгоритмов;
    * блок схемы алгоритмов;
    * зависимость времени работы алгоритмов от данных;
    * вывод.
    
 5*. Задание со звездочкой. Наивная реализация алгоритмов вряд ли будет эффективной. Для улучшения скорости работы вашего кода используйте профайлер, чтобы найти тонкие места реализации алгоритмов. После проведенного профайлинга модифицируйте код для улучшения производительности.
 
 
 ## Полезные ссылки
 * https://eax.me/c-cpp-profiling/
 * https://docs.microsoft.com/ru-ru/visualstudio/profiling/beginners-guide-to-performance-profiling?view=vs-2019
 * http://www.brendangregg.com/perf.html
